<!DOCTYPE html>
<html lang="en">
        <head>
                <title>three.js canvas - camera - orthographic</title>
                <meta charset="utf-8">
                <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
                <style>
                        body {
                                font-family: Monospace;
                                background-color: #f0f0f0;
                                margin: 0px;
                                overflow: hidden;
                        }
                </style>
        </head>
        <body>

                <script src="http://code.jquery.com/jquery-1.10.1.min.js"></script>
                <script src="bluebird.js"></script>
                <script src="three.js"></script>
                <script src="lodash.js"></script>
                <script src="FirstPersonControls.js"></script>
                <script src="QuadTree.js"></script>
				<script type="x-shader/x-vertex" id="vertexshader">
						varying vec4 col;


                        void main() {
								vec3 fpos = vec3(position.x, position.y < 100.0 ? 100.0 : position.y, position.z);

                                vec4 mvPosition = modelViewMatrix * vec4( fpos, 1.0 );
                                gl_Position = projectionMatrix * mvPosition;
								if (position.y < 100.0)
									col = vec4(0.0, 0.0, 0.5, 1.0);
								else if(position.y < 190.0)
									col = vec4(0.0, 1.0, 0.0, 1.0);
								else
									col = vec4(1.0, 1.0, 1.0, 1.0);
                        }

                </script>

                <script type="x-shader/x-fragment" id="fragmentshader">
						varying vec4 col;

                        void main() {
                                gl_FragColor = col;
                        }

                </script>
				
                <script>

                        var container;
                        var camera, scene, renderer;
						var controls;
						var qTree;

						// jquery doesn't do binary download, so we do it ourselves
						var getBinary = function(url) {
							return new Promise(function(resolve, reject) {
								var oReq = new XMLHttpRequest();
								oReq.open("GET", url, true);
								oReq.responseType = "arraybuffer";

								oReq.onload = function(oEvent) {
									if (oReq.status == 200) {
										return resolve(oReq.response);
									}

									reject(new Error("Could not get binary data"));
								};

								oReq.send();
							});
						};

						var getJSON = function(url) {
							return new Promise(function(res, rej) {
								$.getJSON(url, res);
							});
						};

						var mkUrl = function(d) {
							return "/points/cloud/"
								+ d.x + "/"
								+ d.z + "/"
								+ d.width + "/"
								+ d.height;
						};

						$(function() {
							init().then(function() {
								animate();
							}).done();
						});

						var doDataQuery = function() {
							console.log('Do data query');

							var nodes = [];
							qTree.lodQuery({
								x: camera.position.x,
								y: camera.position.z }, function(node) {
								nodes.push(node);
							});

							console.log(nodes.length);

							var promises =
								_.map(nodes, function(n) {
									console.log(n);
									if (!n.loadGeometry) {
										n.loadGeometry = function() {
											if (n.ps !== undefined)
												return n.ps;

											var url = mkUrl( {
												x: n.x,
												z: n.y,
												width: n.w,
												height: n.h });

											console.log(url);

											return getBinary(url).then(function(data) {
												var floatArray = new Float32Array(data);
												var geom = new THREE.BufferGeometry();
												geom.addAttribute('position', Float32Array, floatArray.length / 3, 3);

												var pos = geom.attributes.position.array;

												for (var i = 0, il = pos.length ; i < il ; i += 3) {
													pos[i] = floatArray[i];
													pos[i+1] = floatArray[i+1];
													pos[i+2] = floatArray[i+2];
												}


												var material = new THREE.ShaderMaterial({
													vertexShader: $("#vertexshader").text(),
													fragmentShader: $("#fragmentshader").text()
												});

												n.ps = new THREE.ParticleSystem(geom, material);
												return n.ps;
											});
										};
									}
									return n.loadGeometry();
								});


							Promise.all(promises).then(function(pss) {
								_.forEach(pss, function(ps) {
									scene.add(ps);
								});
							}).done();
						}


                        function init() {
                                container = document.createElement( 'div' );
                                document.body.appendChild( container );

                                var info = document.createElement( 'div' );
                                info.style.position = 'absolute';
                                info.style.top = '10px';
                                info.style.width = '100%';
                                info.style.textAlign = 'center';
                                info.innerHTML = '<a href="http://threejs.org" target="_blank">three.js</a> - orthographic view';
                                container.appendChild( info );

								var width = window.innerWidth;
								var height = window.innerHeight;

                                camera = new THREE.PerspectiveCamera(45, width / height, 1, 10000);
								controls = new THREE.FirstPersonControls(camera);
								controls.lookSpeed = 0.00001;
								controls.movementSpeed = 0.1;
								controls.activeLook = true;

                                scene = new THREE.Scene();


                                renderer = new THREE.WebGLRenderer();
								renderer.setClearColor("#111");
                                renderer.setSize( window.innerWidth, window.innerHeight );

                                container.appendChild( renderer.domElement );

                                window.addEventListener( 'resize', onWindowResize, false );

								return getJSON("/points/bounds").then(function(bounds) {
									camera.position.set(0, 500, 0);

									var maxDepth = 
										Math.log((bounds.width * bounds.height) /
											(bounds.leaf.width * bounds.leaf.height)) / Math.log(4);

									qTree = new QuadTree(bounds.x, bounds.z, bounds.width, bounds.height, maxDepth)
									return bounds;
								});
                        }

                        function onWindowResize() {

                                camera.left = window.innerWidth / - 2;
                                camera.right = window.innerWidth / 2;
                                camera.top = window.innerHeight / 2;
                                camera.bottom = window.innerHeight / - 2;

                                camera.updateProjectionMatrix();

                                renderer.setSize( window.innerWidth, window.innerHeight );

                        }

						var last_d = 0;
						var lastCameraPos = null;

                        function animate() {
							var thisTime = (new Date()).getTime();
							var d = (last_d === 0 ? 0 : (thisTime - last_d));
							last_d = thisTime;

							if (lastCameraPos === null || lastCameraPos.distanceToSquared(camera.position) > 1000.0) {
								lastCameraPos = camera.position.clone();

								doDataQuery();
							}

							requestAnimationFrame( animate );
							render(d);
                        }

                        function render(delta) {
							controls.update(delta);
							renderer.render( scene, camera );
                        }

                </script>

        </body>
</html>
 
